\section{Architecture}
In order to maintain flexibility in our bot's behaviors we designed it in a modular and hierarchical fashion to fit the conceptual model in Figure \ref{conceptualModel}. As mentioned before we did, however, not implement anything sophisticated for anything above the squad-level and focused on the micro-management.
This architecture and the addition of behaviors tree was perfectly fitted for the development of multiple bots -- only small parts of the code has to be change to improve/change the bot behavior.
%It also looks like a human hierarchy -- facilitating the conception of each bot.

For the behaviors trees we used the library libbehavior \cite{libbehavior}.

The squad managers develloped are the following:
\begin{shortitem}
\item \texttt{Attack Closest:} Every unit attack their closest opponent.
\item \texttt{Attack Closest -- No Over-Kill:} Every unit attack the closest opponent that will not die soon (\emph{i.e.} the amount of damage attributed to this unit is not already enough to kill him soon).
\item \texttt{Kiting:} Every unit attacks their closest opponent applying a kiting strategy.
\item \texttt{UCT-Searching:} A searching algorithm based on Monte-Carlo algorithm (UCT: \emph{Upper Confident Bound}).
\item \texttt{ABCD-Searching:} A searching algorithm based on the alpha-beta algorithm adapted to durative moves (ABCD: \emph{Alpha-Beta Considering Durations}).
\end{shortitem}

The first three of these squad managers don't make any plan for the future of the game, and only act in a purely reactive way according to some preset conditions. 
It should also be noted that in the ``overkill'' versions, the units don't share any information with each other, whereas in the no over-kill version they share the information about which target they will attack next. 
In the searching squad managers, on the other hand, the units are all considered as a single entity, like the fingers of a hand, and are coordinated.
